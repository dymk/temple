/**
 * Temple (C) Dylan Knutson, 2013, distributed under the:
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 */

module temple.temple;

private import
	temple.util,
	temple.delims,
	temple.func_string_gen;

public import
	temple.temple,
	temple.temple_context,
	temple.output_stream,
	temple.vibe;

/**
 * Temple
 * Main template for generating Temple functions
 */
template Temple(string __TempleString, __Filter = void)
{
	alias Temple = Temple!(__TempleString, "InlineTemplate", __Filter);
}

template Temple(
	string __TempleString,
	string __TempleName,
	__Filter = void)
{
	// __TempleString: The template string to compile
	// __TempleName: The template's file name, or 'InlineTemplate'
	// __Filter: FP for the rendered template

	// Is a Filter present?
	enum __TempleHasFP = !is(__Filter == void);

	// Needs to be kept in sync with the param name of the Filter
	// passed to Temple
	enum __TempleFilterIdent = __TempleHasFP ? "__Filter" : "";

	// Generates the actual function string, with the function name being
	// `TempleFunc`.
	const __TempleFuncStr = __temple_gen_temple_func_string(
		__TempleString,
		__TempleName,
		__TempleFilterIdent);

	//pragma(msg, temple_fun_str);

	#line 411 "TempleFunc"
	mixin(__TempleFuncStr);
	#line 413 "src/temple/temple.d"

	static if(__TempleHasFP) {
		alias Temple = TempleFunc!__Filter;
	}
	else {
		alias Temple = TempleFunc;
	}
}

/**
 * TempleFile
 * Compiles a file on the disk into a Temple render function
 * Takes an optional Filter
 */
template TempleFile(string template_file, Filter = void)
{
	pragma(msg, "Compiling ", template_file, "...");
	alias TempleFile = Temple!(import(template_file), template_file, Filter);
}

/**
 * TempleLayout
 * Sets up a template to be used as an enclosing layout for a nested Temple
 * template
 * Takes an optional Filter
 */
template TempleLayout(string template_string, Filter = void)
{
	alias layout_renderer = Temple!(template_string, Filter);
	alias TempleLayout = TempleLayoutImpl!layout_renderer;
}

/**
 * TempleLayout
 * Sets up a file to be used as an enclosing layout for a nested Temple
 * template
 * Takes an optional Filter
 */
template TempleLayoutFile(string template_file, Filter = void)
{
	alias layout_renderer = TempleFile!(template_file, Filter);
	alias TempleLayoutFile = TempleLayoutImpl!layout_renderer;
}

/*
 * Implementation for a Temple layout function
 */
package void TempleLayoutImpl(alias layout_renderer)(
	OutputStream buff,
	TempleFuncType* temple_func,
	TempleContext context = null)
{
	// always ensure that a context is present
	if(context is null)
	{
		context = new TempleContext();
	}

	auto old_partial = context.partial;
	context.partial = temple_func;
	scope(exit)
	{
		context.partial = old_partial;
	}

	layout_renderer(buff, context);
}

/**
 * TempleFilter
 * Partial application of a Filter to be used with the Temple* family of templates
 */
template TempleFilter(Filter) {
	template Temple(ARGS...) {
		alias Temple = .Temple!(ARGS, Filter);
	}

	template TempleFile(ARGS...) {
		alias TempleFile = .TempleFile!(ARGS, Filter);
	}

	template TempleLayout(ARGS...) {
		alias TempleLayout = .TempleLayout!(ARGS, Filter);
	}

	template TempleLayoutFile(ARGS...) {
		alias TempleLayoutFile = .TempleLayoutFile!(ARGS, Filter);
	}
}

/**
 * TempleFuncType
 * TempleLayoutFuncType
 *
 * Function signatures for a Temple template, and layout template,
 * which are `void function(OutputStream, TempleContext = null)` and
 *           `void function(OutputStream, TempleFuncType*, TempleContext = null)`
 * respectivly
 */
alias TempleFuncType = typeof(Temple!("", ""));
alias TempleLayoutFuncType = typeof(TempleLayoutImpl!(Temple!("", "")));

/**
 * Helper functions for quicly rendering a template as a string
 */
string templeToString(TempleFuncType* func, TempleContext context = null)
{
	auto accum = new AppenderOutputStream;
	(*func)(accum, context);
	return accum.data;
}

string templeToString(TempleLayoutFuncType* layout, TempleFuncType* partial, TempleContext context = null)
{
	auto accum = new AppenderOutputStream;
	(*layout)(accum, partial, context);
	return accum.data;
}

